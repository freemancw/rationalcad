/*!
 * Notes on my answers to the programming test.
 *
 * @author Clinton Freeman <freeman@cs.unc.edu>
 * @date 12/22/2013
 */

//=============================================================================
// General
//=============================================================================

I used C++ for all problems. AFAIK, I used two C++11 features: the auto keyword,
and using begin(container) and end(container) instead of container.begin() and
container.end().

//=============================================================================
// Problem #1. Reverse words
//=============================================================================

For an input string consisting of n characters, my algorithm makes two in-place
passes over the string, first reversing all characters irrespective of
whitespace, then reversing each word individually in a left-to-right traversal.
It uses O(n) time and O(1) space, since each pass is also linear with a constant
space requirement.

Relevant files:
  - bt_reverse.h
  - bt_reverse.cpp

//=============================================================================
// Problem #2. Duplicate list
//=============================================================================

Relevant files:
  - bt_duplicate.h
  - bt_duplicate.cpp

//=============================================================================
// Problem #3. Line segments
//=============================================================================

Relevant files:
  - bt_segments.h
  - bt_segments.cpp

//=============================================================================
// Problem #4. Boggle
//=============================================================================

===================================== Part 1: Dictionary data structure choice.

I use a Trie data structure to store the given dictionary based on the
observation that we may quit exploring some path through the board once we've
determined that the current string is not a prefix for any words in the
dictionary. Tries are particularly well suited to this task since it is simply
a matter of checking if the node corresponding to the string in question has
any children. While I considered using a hash table, there isn't an inherent
relationship between the hashed values of strings with common prefixes, so a
hash table based algorithm would need to investigate all possible boggle
strings, which seemed to lead to an exponential time algorithm.

There are a number of ways to implement Tries - the primary difference is the
way in which children are stored. Each way comes with different time/space
characteristics. In particular, a Trie built for a language with N characters,
we might do any of the following:

  (1) Store an array of N child pointers, one for each possible character. This
      gives O(1) access time at the cost of a potentially large amount of
      unused space.
  (2) Store an list of child pointers that may range in size from 0...N. This
      is simple and does not waste space, but we pay with an access time linear
      in the number of pointers at a particular node.
  (3) Store a BST of child pointers. This gives access time logarithmic in the
      number of pointers at each node, but uses more space than the list.

My implementation uses (2) for simplicity, since it wasn't immediately obvious
which would be "better." An extensive analysis of Tries can be found in
Sedgewick's "Algorithms" and "Introduction to Algorithm Analysis."

================================ Part 2: Algorithm description and performance.

Without being particularly formal, my algorithm uses divide and conquer on each
board cell to produce NxM disjoint subproblems. Then, for each subproblem, it
uses dynamic programming to search through all possible words that may be
generated by the given start cell. Once a recursive call realizes that the
current path through the board is incapable of generating any more words in the
dictionary, further exploration is cut short. By memoizing the prefix string
and current node in the dictionary Trie, it avoids repeated computation.

Currently, I provide only a recursive implementation of the algorithm, but
given more time I would write an iterative version to reduce overhead.

Relevant files:
  - bt_array.h
  - bt_boggle.h
  - bt_boggle.cpp
